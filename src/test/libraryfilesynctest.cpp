#include <gtest/gtest.h>

#include <QFile>
#include <QFileInfo>
#include <QTemporaryDir>
#include <memory>

#include "library/library_prefs.h"
#include "sources/metadatasource.h"
#include "test/librarytest.h"
#include "track/track.h"
#include "util/fileinfo.h"

namespace {

const auto kTestDir = QDir(QDir::current().absoluteFilePath("src/test/id3-test-data"));

const auto kTestFileWithMetadata = QFileInfo(kTestDir, QStringLiteral("cover-test-jpg.mp3"));

const auto kTestFileWithoutMetadata = QFileInfo(kTestDir, QStringLiteral("empty.mp3"));

enum class FileType {
    WithMetadata,
    WithoutMetadata,
};

void sleepBeforeUpdatingFileLastModifiedTime() {
    // Ensure that the next file modification time stamp generated
    // by the file system will be strictly greater than the previous
    // one. The preconditions of some tests require a strictly monotonic
    // sequence of time stamps for reliably detecting file modifications.
    //
    // This grace period seems to be mandatory at least for the CI
    // test runs and might need to be adjusted depending on the
    // results for different platforms.
    QThread::msleep(1);
}

/// A temporary file system with a single audio file.
class TempFileSystem {
  public:
    explicit TempFileSystem(const QFileInfo& testFile)
            : m_fileInfo(m_tempDir.filePath(testFile.fileName())) {
        EXPECT_TRUE(m_tempDir.isValid());
        EXPECT_FALSE(m_fileInfo.exists());
        mixxxtest::copyFile(
                testFile.absoluteFilePath(),
                m_fileInfo.location());
        EXPECT_TRUE(m_fileInfo.exists());
        EXPECT_TRUE(fileLastModified().isValid());
    }

    const mixxx::FileInfo& fileInfo() const {
        return m_fileInfo;
    }

    QDateTime fileLastModified() const {
        return m_fileInfo.toQFile().fileTime(QFileDevice::FileModificationTime);
    }

    void updateFileLastModified() const {
        auto file = m_fileInfo.toQFile();
        const auto oldLastModified = fileLastModified();
        ASSERT_TRUE(oldLastModified.isValid());
        // Rely on the OS to generate the time stamps instead of using
        // QFileDevice::setFileTime() with a time stamp generated by
        // QDateTime. The latter has proven to produce non-monotonic
        // sequences of time stamps when mixed with the file system
        // time stamps.
        auto newLastModified = oldLastModified;
        do {
            sleepBeforeUpdatingFileLastModifiedTime();
            ASSERT_TRUE(file.open(
                    QIODevice::ReadWrite |
                    QIODevice::ExistingOnly |
                    QIODevice::Append));
            const auto fileSize = file.size();
            // Grow and shrink the file to bump the modification time stamp
            ASSERT_TRUE(file.resize(fileSize + 1));
            ASSERT_TRUE(file.flush());
            ASSERT_TRUE(file.resize(fileSize));
            file.close();
            ASSERT_EQ(newLastModified, oldLastModified);
            newLastModified = fileLastModified();
            ASSERT_TRUE(newLastModified.isValid());
            ASSERT_GE(newLastModified, oldLastModified);
            // Looping is required to fix spurious CI test failures
            // for Ubuntu 20.04 where the time stamps sometimes do not
            // progress as expected, i.e. the new time stamp might equal
            // the old time stamp even though the file was modified.
        } while (newLastModified <= oldLastModified);
        // The new modification time must be strictly greater than
        // the old modification time to establish valid preconditions
        // for the tests! Since those time stamps are generated as
        // side effects by the OS we need these ugly quirks here.
        ASSERT_GT(newLastModified, oldLastModified);
    }

    void removeFile() const {
        ASSERT_TRUE(m_fileInfo.toQFile().remove());
    }

  private:
    const QTemporaryDir m_tempDir;
    const mixxx::FileInfo m_fileInfo;
};

class SyncTrackMetadataConfigScope final {
  public:
    explicit SyncTrackMetadataConfigScope(
            UserSettingsPointer pConfig)
            : m_pConfig(std::move(pConfig)),
              m_syncTrackMetadataBackup(
                      m_pConfig->getValue(
                              mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                              false)) {
    }
    ~SyncTrackMetadataConfigScope() {
        // Restore config
        m_pConfig->setValue(
                mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                m_syncTrackMetadataBackup);
    }

    void setConfig(bool syncTrackMetadata) const {
        m_pConfig->setValue(
                mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                syncTrackMetadata);
    }

  private:
    const UserSettingsPointer m_pConfig;
    const bool m_syncTrackMetadataBackup;
};

} // namespace

class LibraryFileSyncTest : public LibraryTest {
  protected:
    explicit LibraryFileSyncTest(const QFileInfo& testFile)
            : m_tempFileSystem(testFile) {
        const auto trackRef = TrackRef::fromFileInfo(m_tempFileSystem.fileInfo());
        EXPECT_FALSE(trackCollectionManager()->getTrackByRef(trackRef));
        const auto pTrack = getOrAddTrackByLocation(trackRef.getLocation());
        EXPECT_TRUE(trackCollectionManager()->getTrackByRef(trackRef));
        m_trackId = pTrack->getId();
    }

    TrackPointer loadTrack() const {
        const auto pTrack = trackCollectionManager()->getTrackById(m_trackId);
        DEBUG_ASSERT(pTrack);
        return pTrack;
    }

    void saveModifiedTrack(TrackPointer&& pTrack) const {
        ASSERT_NE(nullptr, pTrack);
        ASSERT_EQ(1, pTrack.use_count());
        const auto trackId = pTrack->getId();
        ASSERT_TRUE(trackId.isValid());
        ASSERT_TRUE(pTrack->isDirty());
        // The file might be modified if track metadata is exported.
        // Ensures that the resulting time stamp will be strictly
        // greater than the current one.
        sleepBeforeUpdatingFileLastModifiedTime();
        pTrack.reset();
        ASSERT_EQ(nullptr, GlobalTrackCacheLocker().lookupTrackById(trackId));
    }

    void verifySourceSyncStatusOfTrack(
            const Track& track,
            mixxx::TrackRecord::SourceSyncStatus expectedSourceSyncStatus) const {
        const auto trackRecord = track.getRecord();
        EXPECT_EQ(expectedSourceSyncStatus,
                trackRecord.checkSourceSyncStatus(track.getFileInfo()));

        // Verify all time stamps for consistency
        const auto sourceSynchronizedAt = trackRecord.getSourceSynchronizedAt();
        const auto fileLastModified = m_tempFileSystem.fileLastModified();
        switch (expectedSourceSyncStatus) {
        case mixxx::TrackRecord::SourceSyncStatus::Void:
        case mixxx::TrackRecord::SourceSyncStatus::Synchronized:
            EXPECT_TRUE(sourceSynchronizedAt.isValid());
            EXPECT_TRUE(fileLastModified.isValid());
            EXPECT_EQ(fileLastModified, sourceSynchronizedAt);
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Outdated:
            EXPECT_TRUE(sourceSynchronizedAt.isValid());
            EXPECT_TRUE(fileLastModified.isValid());
            EXPECT_GT(fileLastModified, sourceSynchronizedAt);
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Unknown:
            EXPECT_FALSE(sourceSynchronizedAt.isValid());
            // Independent of if the file is accessible or not
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Undefined:
            EXPECT_TRUE(sourceSynchronizedAt.isValid());
            EXPECT_FALSE(fileLastModified.isValid());
            break;
        default:
            ASSERT_FALSE("unreachable");
        }
    }

    TrackPointer reloadTrackFromDatabaseAndVerifySourceSyncStatus(
            mixxx::TrackRecord::SourceSyncStatus expectedSourceSyncStatus) const {
        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Disable sync
        syncTrackMetadataConfigScope.setConfig(false);

        const auto pTrack = loadTrack();
        EXPECT_NE(nullptr, pTrack);
        verifySourceSyncStatusOfTrack(*pTrack, expectedSourceSyncStatus);

        return pTrack;
    }

    void modifyAndSaveTrack(
            TrackPointer&& pTrack,
            FileType fileType,
            bool syncTrackMetadata) {
        ASSERT_NE(nullptr, pTrack);

        const auto fileLastModifiedBefore = m_tempFileSystem.fileLastModified();
        /*non-const*/ auto trackRecordBefore = pTrack->getRecord();
        const auto sourceSyncStatusBefore =
                trackRecordBefore.checkSourceSyncStatus(pTrack->getFileInfo());

        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Configure sync
        syncTrackMetadataConfigScope.setConfig(syncTrackMetadata);

        // Modify track metadata
        const QString newTitle = pTrack->getTitle() + QStringLiteral("modified");
        pTrack->setTitle(newTitle);

        // Save the track
        saveModifiedTrack(std::move(pTrack));
        ASSERT_EQ(nullptr, pTrack);

        // Disable sync temporarily for the final verification to prevent
        // reimporting metadata from the file unintentionally, i.e. switch
        // the library into read-only mode.
        syncTrackMetadataConfigScope.setConfig(false);

        const auto fileLastModifiedAfter = m_tempFileSystem.fileLastModified();
        ASSERT_EQ(fileLastModifiedAfter.isValid(), fileLastModifiedBefore.isValid());
        if (syncTrackMetadata && fileType == FileType::WithMetadata) {
            // Verify that the file has been modified upon saving
            ASSERT_TRUE(
                    !fileLastModifiedAfter.isValid() ||
                    fileLastModifiedAfter > fileLastModifiedBefore);
        } else {
            // Verify that the file has not been modified upon saving
            ASSERT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);
        }

        mixxx::MetadataSource::ImportResult expectedImportResult;
        switch (fileType) {
        case FileType::WithMetadata:
            expectedImportResult = mixxx::MetadataSource::ImportResult::Succeeded;
            break;
        case FileType::WithoutMetadata:
            expectedImportResult = mixxx::MetadataSource::ImportResult::Unavailable;
            break;
        default:
            ASSERT_FALSE("unreachable");
        }

        auto expectedSourceSyncStatusAfter = sourceSyncStatusBefore;
        switch (sourceSyncStatusBefore) {
        case mixxx::TrackRecord::SourceSyncStatus::Unknown:
        case mixxx::TrackRecord::SourceSyncStatus::Outdated:
            if (syncTrackMetadata &&
                    fileType == FileType::WithMetadata) {
                expectedSourceSyncStatusAfter = mixxx::TrackRecord::SourceSyncStatus::Synchronized;
            }
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Void:
        case mixxx::TrackRecord::SourceSyncStatus::Undefined:
            expectedImportResult = mixxx::MetadataSource::ImportResult::Unavailable;
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Synchronized:
            break;
        default:
            ASSERT_FALSE("unreachable");
        }

        if (syncTrackMetadata &&
                !fileLastModifiedAfter.isValid()) {
            // The source sync timestamp should be reset if the track
            // metadata export failed due to an inaccessible file.
            expectedSourceSyncStatusAfter = mixxx::TrackRecord::SourceSyncStatus::Unknown;
        }

        // Verify that the modified metadata is still present after
        // reloading the track from the database
        pTrack = reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                expectedSourceSyncStatusAfter);
        ASSERT_NE(nullptr, pTrack);
        const auto trackRecordAfter = pTrack->getRecord();

        // Reimport metadata from the file
        mixxx::TrackMetadata importedTrackMetadata;
        auto [importResult, sourceSynchronizedAt] =
                SoundSourceProxy(pTrack).importTrackMetadataAndCoverImage(
                        &importedTrackMetadata, nullptr);
        EXPECT_EQ(expectedImportResult, importResult);

        if (syncTrackMetadata) {
            // Verify that the synchronization time stamp has been reset
            // if the file is inaccessible, i.e. after export of track metadata
            // has failed.
            EXPECT_TRUE(
                    fileLastModifiedAfter.isValid() ||
                    !trackRecordAfter.getSourceSynchronizedAt().isValid());
            if (fileType == FileType::WithMetadata) {
                // The stream info properties might be adjusted when exporting track metadata!
                // We have to adjust trackRecordBefore and importedTrackMetadata accordingly
                // before continuing with the verification.
                trackRecordBefore.refMetadata().refStreamInfo() =
                        trackRecordAfter.getMetadata().getStreamInfo();
                if (importResult == mixxx::MetadataSource::ImportResult::Succeeded) {
                    importedTrackMetadata.refStreamInfo() =
                            trackRecordAfter.getMetadata().getStreamInfo();
                    // Verify that the metadata in the file has been modified.
                    EXPECT_LT(fileLastModifiedBefore, sourceSynchronizedAt);
                    EXPECT_EQ(trackRecordAfter.getSourceSynchronizedAt(), sourceSynchronizedAt);
                    EXPECT_EQ(trackRecordAfter.getMetadata(), importedTrackMetadata);
                }
                // Verify that the synchronization time stamp has been updated
                // if the file still exists.
                EXPECT_TRUE(
                        !fileLastModifiedAfter.isValid() ||
                        !trackRecordBefore.getSourceSynchronizedAt().isValid() ||
                        trackRecordBefore.getSourceSynchronizedAt() <
                                trackRecordAfter.getSourceSynchronizedAt());
            } else {
                // Verify that the file has not been modified upon saving
                ASSERT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);
                // Verify that the synchronization time stamp has not been updated
                // if the file still exists.
                EXPECT_TRUE(
                        !fileLastModifiedAfter.isValid() ||
                        trackRecordBefore.getSourceSynchronizedAt() ==
                                trackRecordAfter.getSourceSynchronizedAt());
            }
        } else {
            // Verify that the file has not been modified upon saving
            ASSERT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);
            // Verify that the synchronization time stamp has not been updated.
            EXPECT_EQ(
                    trackRecordAfter.getSourceSynchronizedAt(),
                    trackRecordBefore.getSourceSynchronizedAt());
            if (importResult == mixxx::MetadataSource::ImportResult::Succeeded) {
                // Verify that the metadata in the file has not been modified.
                EXPECT_EQ(fileLastModifiedBefore, sourceSynchronizedAt);
                EXPECT_EQ(trackRecordBefore.getMetadata(), importedTrackMetadata);
            }
        }

        // Verify that the metadata in the database has been modified.
        EXPECT_NE(trackRecordBefore.getMetadata(), trackRecordAfter.getMetadata());
        EXPECT_EQ(newTitle, pTrack->getTitle());
    }

    QDateTime
    fileLastModified() const {
        return m_tempFileSystem.fileLastModified();
    }

    void updateFileLastModified() const {
        m_tempFileSystem.updateFileLastModified();
    }

    void removeFile() const {
        m_tempFileSystem.removeFile();
    }

    virtual TrackPointer prepareTestTrack() const = 0;

    void checkTrackRecordSourceSyncStatus(
            mixxx::TrackRecord::SourceSyncStatus expectedSourceSyncStatus) const {
        const auto pTrack = prepareTestTrack();
        const mixxx::TrackRecord emptyTrackRecord;
        EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Void,
                emptyTrackRecord.checkSourceSyncStatus(pTrack->getFileInfo()));
        const auto trackRecordOfTestTrack = pTrack->getRecord();
        EXPECT_EQ(expectedSourceSyncStatus,
                trackRecordOfTestTrack.checkSourceSyncStatus(pTrack->getFileInfo()));
    }

  private:
    TempFileSystem m_tempFileSystem;
    TrackId m_trackId;
};

class LibraryFileSyncStatusSynchronizedTest : public LibraryFileSyncTest {
  protected:
    explicit LibraryFileSyncStatusSynchronizedTest(const QFileInfo& testFile)
            : LibraryFileSyncTest(testFile) {
    }

    TrackPointer prepareTestTrack() const override {
        return reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Synchronized);
    }

    void checkTrackRecordSourceSyncStatus() const {
        LibraryFileSyncTest::checkTrackRecordSourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Synchronized);
    }
};

class LibraryFileWithMetadataSyncStatusSynchronizedTest
        : public LibraryFileSyncStatusSynchronizedTest {
  public:
    LibraryFileWithMetadataSyncStatusSynchronizedTest()
            : LibraryFileSyncStatusSynchronizedTest(kTestFileWithMetadata) {
    }
};

TEST_F(LibraryFileWithMetadataSyncStatusSynchronizedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusSynchronizedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithMetadataSyncStatusSynchronizedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, true);
}

TEST_F(LibraryFileWithMetadataSyncStatusSynchronizedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, false);
}

class LibraryFileWithoutMetadataSyncStatusSynchronizedTest
        : public LibraryFileSyncStatusSynchronizedTest {
  public:
    LibraryFileWithoutMetadataSyncStatusSynchronizedTest()
            : LibraryFileSyncStatusSynchronizedTest(kTestFileWithoutMetadata) {
    }
};

TEST_F(LibraryFileWithoutMetadataSyncStatusSynchronizedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusSynchronizedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithoutMetadataSyncStatusSynchronizedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, true);
}

TEST_F(LibraryFileWithoutMetadataSyncStatusSynchronizedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, false);
}

class LibraryFileSyncStatusOutdatedTest : public LibraryFileSyncTest {
  public:
    explicit LibraryFileSyncStatusOutdatedTest(const QFileInfo& testFile)
            : LibraryFileSyncTest(testFile) {
    }

  protected:
    TrackPointer prepareTestTrack() const override {
        // Touch the file's modification time stamp to simulate an
        // independent file modification by a 3rd party app.
        updateFileLastModified();

        // The track is loaded directly from the database and will still
        // have the previous synchronization time stamp. It should then
        // be detected as outdated.
        return reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Outdated);
    }

    void checkTrackRecordSourceSyncStatus() const {
        LibraryFileSyncTest::checkTrackRecordSourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Outdated);
    }
};

class LibraryFileWithMetadataSyncStatusOutdatedTest : public LibraryFileSyncStatusOutdatedTest {
  public:
    LibraryFileWithMetadataSyncStatusOutdatedTest()
            : LibraryFileSyncStatusOutdatedTest(kTestFileWithMetadata) {
    }
};

TEST_F(LibraryFileWithMetadataSyncStatusOutdatedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusOutdatedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithMetadataSyncStatusOutdatedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, true);
}

TEST_F(LibraryFileWithMetadataSyncStatusOutdatedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, false);
}

TEST_F(LibraryFileWithMetadataSyncStatusOutdatedTest, reimportTrackMetadataWithSyncEnabled) {
    const mixxx::TrackRecord outdatedTrackRecord =
            prepareTestTrack()->getRecord();

    const auto syncTrackMetadataConfigScope =
            SyncTrackMetadataConfigScope(m_pConfig);

    // Enable sync
    syncTrackMetadataConfigScope.setConfig(true);

    auto pTrack = loadTrack();
    ASSERT_TRUE(pTrack);
    const auto importedTrackRecord = pTrack->getRecord();
    verifySourceSyncStatusOfTrack(
            *pTrack, mixxx::TrackRecord::SourceSyncStatus::Synchronized);
    EXPECT_LT(
            outdatedTrackRecord.getSourceSynchronizedAt(),
            importedTrackRecord.getSourceSynchronizedAt());
}

TEST_F(LibraryFileWithMetadataSyncStatusOutdatedTest, doNotReimportTrackMetadataWithSyncDisabled) {
    const mixxx::TrackRecord outdatedTrackRecord =
            prepareTestTrack()->getRecord();

    const auto syncTrackMetadataConfigScope =
            SyncTrackMetadataConfigScope(m_pConfig);

    // Disable sync
    syncTrackMetadataConfigScope.setConfig(false);

    auto pTrack = loadTrack();
    ASSERT_TRUE(pTrack);
    const auto loadedTrackRecord = pTrack->getRecord();
    verifySourceSyncStatusOfTrack(
            *pTrack, mixxx::TrackRecord::SourceSyncStatus::Outdated);
    EXPECT_EQ(outdatedTrackRecord, loadedTrackRecord);
}

class LibraryFileWithoutMetadataSyncStatusOutdatedTest : public LibraryFileSyncStatusOutdatedTest {
  public:
    LibraryFileWithoutMetadataSyncStatusOutdatedTest()
            : LibraryFileSyncStatusOutdatedTest(kTestFileWithoutMetadata) {
    }
};

TEST_F(LibraryFileWithoutMetadataSyncStatusOutdatedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusOutdatedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithoutMetadataSyncStatusOutdatedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, true);
}

TEST_F(LibraryFileWithoutMetadataSyncStatusOutdatedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, false);
}

class LibraryFileSyncStatusUnknownTest : public LibraryFileSyncTest {
  public:
    explicit LibraryFileSyncStatusUnknownTest(const QFileInfo& testFile)
            : LibraryFileSyncTest(testFile) {
    }

  protected:
    TrackPointer prepareTestTrack() const override {
        TrackPointer pTrack =
                reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                        mixxx::TrackRecord::SourceSyncStatus::Synchronized);
        EXPECT_NE(nullptr, pTrack);

        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Disable sync
        syncTrackMetadataConfigScope.setConfig(false);

        const auto fileLastModifiedBefore = fileLastModified();

        // The column contains NULL as the default value, i.e. the last
        // synchronization time is unknown.
        pTrack->resetSourceSynchronizedAt();
        // Write the data into the database (without modifying the file)
        saveModifiedTrack(std::move(pTrack));
        EXPECT_EQ(nullptr, pTrack);

        // Verify that the file has not been modified
        const auto fileLastModifiedAfter = fileLastModified();
        EXPECT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);

        return reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Unknown);
    }

    void checkTrackRecordSourceSyncStatus() const {
        LibraryFileSyncTest::checkTrackRecordSourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Unknown);
    }
};

class LibraryFileWithMetadataSyncStatusUnknownTest : public LibraryFileSyncStatusUnknownTest {
  public:
    LibraryFileWithMetadataSyncStatusUnknownTest()
            : LibraryFileSyncStatusUnknownTest(kTestFileWithMetadata) {
    }
};

TEST_F(LibraryFileWithMetadataSyncStatusUnknownTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusUnknownTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithMetadataSyncStatusUnknownTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, true);
}

TEST_F(LibraryFileWithMetadataSyncStatusUnknownTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, false);
}

class LibraryFileWithoutMetadataSyncStatusUnknownTest : public LibraryFileSyncStatusUnknownTest {
  public:
    LibraryFileWithoutMetadataSyncStatusUnknownTest()
            : LibraryFileSyncStatusUnknownTest(kTestFileWithoutMetadata) {
    }
};

TEST_F(LibraryFileWithoutMetadataSyncStatusUnknownTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusUnknownTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithoutMetadataSyncStatusUnknownTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, true);
}

TEST_F(LibraryFileWithoutMetadataSyncStatusUnknownTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, false);
}

class LibraryFileSyncStatusUndefinedTest : public LibraryFileSyncTest {
  public:
    explicit LibraryFileSyncStatusUndefinedTest(const QFileInfo& testFile)
            : LibraryFileSyncTest(testFile) {
    }

  protected:
    TrackPointer prepareTestTrack() const override {
        removeFile();

        return reloadTrackFromDatabaseAndVerifySourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Undefined);
    }

    void checkTrackRecordSourceSyncStatus() const {
        LibraryFileSyncTest::checkTrackRecordSourceSyncStatus(
                mixxx::TrackRecord::SourceSyncStatus::Undefined);
    }
};

class LibraryFileWithMetadataSyncStatusUndefinedTest : public LibraryFileSyncStatusUndefinedTest {
  public:
    LibraryFileWithMetadataSyncStatusUndefinedTest()
            : LibraryFileSyncStatusUndefinedTest(kTestFileWithMetadata) {
    }
};

TEST_F(LibraryFileWithMetadataSyncStatusUndefinedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusUndefinedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithMetadataSyncStatusUndefinedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, true);
}

TEST_F(LibraryFileWithMetadataSyncStatusUndefinedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithMetadata, false);
}

class LibraryFileWithoutMetadataSyncStatusUndefinedTest
        : public LibraryFileSyncStatusUndefinedTest {
  public:
    LibraryFileWithoutMetadataSyncStatusUndefinedTest()
            : LibraryFileSyncStatusUndefinedTest(kTestFileWithoutMetadata) {
    }
};

TEST_F(LibraryFileWithoutMetadataSyncStatusUndefinedTest, checkTrackRecordSourceSyncStatus) {
    LibraryFileSyncStatusUndefinedTest::checkTrackRecordSourceSyncStatus();
}

TEST_F(LibraryFileWithoutMetadataSyncStatusUndefinedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, true);
}

TEST_F(LibraryFileWithoutMetadataSyncStatusUndefinedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), FileType::WithoutMetadata, false);
}
