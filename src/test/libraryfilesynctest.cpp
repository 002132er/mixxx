#include <gtest/gtest.h>

#include <QFile>
#include <QFileInfo>
#include <QTemporaryDir>
#include <memory>

#include "library/library_prefs.h"
#include "sources/metadatasource.h"
#include "test/librarytest.h"
#include "track/track.h"
#include "util/fileinfo.h"

namespace {

const auto kTestDir = QDir(QDir::current().absoluteFilePath("src/test/id3-test-data"));

const QString kTestFileNameWithMetadata = QStringLiteral("cover-test-jpg.mp3");

const QString kTestFileNameWithoutMetadata = QStringLiteral("empty.mp3");

void sleepAfterFileLastModifiedUpdated() {
    // Ensure that all subsequent modification time stamps will be
    // strictly greater, i.e. strictly monotonic sequence of time
    // stamps. This grace period seems to be mandatory for the CI
    // test runs and might need to be adjusted depending on the
    // results for different platforms.
    QThread::msleep(1);
}

/// A temporary file system with a single audio file.
class TempFileSystem {
  public:
    explicit TempFileSystem(const QString& fileName)
            : m_fileInfo(m_tempDir.filePath(fileName)) {
        createFile();
    }

    const mixxx::FileInfo& fileInfo() const {
        return m_fileInfo;
    }

    QDateTime fileLastModified() const {
        return m_fileInfo.toQFile().fileTime(QFileDevice::FileModificationTime);
    }

    void updateFileLastModified() const {
        auto file = m_fileInfo.toQFile();
        const auto oldLastModified = fileLastModified();
        ASSERT_TRUE(oldLastModified.isValid());
        // Rely on the OS to generate the time stamps instead of using
        // QFileDevice::setFileTime() with a time stamp generated by
        // QDateTime. The latter has proven to produce non-monotonic
        // time stamps that cause spurious test failures.
        ASSERT_TRUE(file.open(QIODevice::ReadWrite | QIODevice::ExistingOnly | QIODevice::Append));
        const auto fileSize = file.size();
        // Grow and shrink the file to bump the modification time stamp
        ASSERT_TRUE(file.resize(fileSize + 1));
        ASSERT_TRUE(file.flush());
        ASSERT_TRUE(file.resize(fileSize));
        file.close();
        const auto newLastModified = fileLastModified();
        ASSERT_TRUE(newLastModified.isValid());
        ASSERT_GT(newLastModified, oldLastModified);
        sleepAfterFileLastModifiedUpdated();
    }

    void removeFile() const {
        ASSERT_TRUE(m_fileInfo.toQFile().remove());
    }

  private:
    void createFile() {
        ASSERT_TRUE(m_tempDir.isValid());
        ASSERT_FALSE(m_fileInfo.exists());
        mixxxtest::copyFile(
                kTestDir.absoluteFilePath(m_fileInfo.fileName()),
                m_fileInfo.location());
        ASSERT_TRUE(m_fileInfo.exists());
        sleepAfterFileLastModifiedUpdated();
    }

    const QTemporaryDir m_tempDir;
    const mixxx::FileInfo m_fileInfo;
};

class SyncTrackMetadataConfigScope final {
  public:
    explicit SyncTrackMetadataConfigScope(
            UserSettingsPointer pConfig)
            : m_pConfig(std::move(pConfig)),
              m_syncTrackMetadataBackup(
                      m_pConfig->getValue(
                              mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                              false)) {
    }
    ~SyncTrackMetadataConfigScope() {
        // Restore config
        m_pConfig->setValue(
                mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                m_syncTrackMetadataBackup);
    }

    void setConfig(bool syncTrackMetadata) const {
        m_pConfig->setValue(
                mixxx::library::prefs::kSyncTrackMetadataConfigKey,
                syncTrackMetadata);
    }

  private:
    const UserSettingsPointer m_pConfig;
    const bool m_syncTrackMetadataBackup;
};

} // namespace

class LibraryFileSyncTest : public LibraryTest {
  protected:
    explicit LibraryFileSyncTest(const QString& fileName)
            : m_tempFileSystem(fileName) {
        createTrack();
    }

    TrackPointer loadTrack() const {
        const auto pTrack = trackCollectionManager()->getTrackById(m_trackId);
        DEBUG_ASSERT(pTrack);
        return pTrack;
    }

    void saveModifiedTrack(TrackPointer&& pTrack) const {
        ASSERT_NE(nullptr, pTrack);
        ASSERT_EQ(1, pTrack.use_count());
        const auto trackId = pTrack->getId();
        ASSERT_TRUE(trackId.isValid());
        ASSERT_TRUE(pTrack->isDirty());
        pTrack.reset();
        ASSERT_EQ(nullptr, GlobalTrackCacheLocker().lookupTrackById(trackId));
        // The file might have been modified if track metadata has been exported.
        sleepAfterFileLastModifiedUpdated();
    }

    void verifySourceSyncStatusOfTrack(
            const Track& track,
            mixxx::TrackRecord::SourceSyncStatus expectedSourceSyncStatus) const {
        const auto trackRecord = track.getRecord();
        EXPECT_EQ(expectedSourceSyncStatus,
                trackRecord.checkSourceSyncStatus(track.getFileInfo()));

        // Verify all time stamps for consistency
        const auto sourceSynchronizedAt = trackRecord.getSourceSynchronizedAt();
        const auto fileLastModified = m_tempFileSystem.fileLastModified();
        switch (expectedSourceSyncStatus) {
        case mixxx::TrackRecord::SourceSyncStatus::Synchronized:
            EXPECT_TRUE(sourceSynchronizedAt.isValid());
            EXPECT_TRUE(fileLastModified.isValid());
            EXPECT_EQ(fileLastModified, trackRecord.getSourceSynchronizedAt());
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Outdated:
            EXPECT_TRUE(sourceSynchronizedAt.isValid());
            EXPECT_TRUE(fileLastModified.isValid());
            EXPECT_GT(fileLastModified, trackRecord.getSourceSynchronizedAt());
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Void:
        case mixxx::TrackRecord::SourceSyncStatus::Unknown:
            EXPECT_FALSE(sourceSynchronizedAt.isValid());
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Undefined:
            EXPECT_FALSE(fileLastModified.isValid());
            break;
        default:
            ASSERT_FALSE("unreachable");
        }
    }

    void loadTrackFromDatabaseAndVerifySourceSyncStatus(
            TrackPointer* pLoadedTrack,
            mixxx::TrackRecord::SourceSyncStatus expectedSourceSyncStatus) const {
        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Disable sync
        syncTrackMetadataConfigScope.setConfig(false);

        const auto pTrack = loadTrack();
        ASSERT_NE(nullptr, pTrack);
        verifySourceSyncStatusOfTrack(*pTrack, expectedSourceSyncStatus);

        if (pLoadedTrack) {
            *pLoadedTrack = std::move(pTrack);
        }
    }

    void modifyAndSaveTrack(TrackPointer&& pTrack, bool syncTrackMetadata) {
        ASSERT_NE(nullptr, pTrack);

        const auto fileLastModifiedBefore = m_tempFileSystem.fileLastModified();
        /*non-const*/ auto trackRecordBefore = pTrack->getRecord();
        const auto sourceSyncStatusBefore =
                trackRecordBefore.checkSourceSyncStatus(pTrack->getFileInfo());

        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Configure sync
        syncTrackMetadataConfigScope.setConfig(syncTrackMetadata);

        // Modify track metadata
        const QString newTitle = pTrack->getTitle() + QStringLiteral("modified");
        pTrack->setTitle(newTitle);

        // Save the track
        saveModifiedTrack(std::move(pTrack));
        ASSERT_EQ(nullptr, pTrack);

        // Disable sync temporarily for the final verification to prevent
        // reimporting metadata from the file unintentionally, i.e. switch
        // the library into read-only mode.
        syncTrackMetadataConfigScope.setConfig(false);

        const auto fileLastModifiedAfter = m_tempFileSystem.fileLastModified();
        ASSERT_EQ(fileLastModifiedAfter.isValid(), fileLastModifiedBefore.isValid());
        if (syncTrackMetadata) {
            // Verify that the file has been modified upon saving
            ASSERT_TRUE(
                    !fileLastModifiedAfter.isValid() ||
                    fileLastModifiedAfter > fileLastModifiedBefore);
        } else {
            // Verify that the file has not been modified upon saving
            ASSERT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);
        }

        auto expectedSourceSyncStatusAfter = sourceSyncStatusBefore;
        auto expectedImportResult = mixxx::MetadataSource::ImportResult::Succeeded;
        switch (sourceSyncStatusBefore) {
        case mixxx::TrackRecord::SourceSyncStatus::Unknown:
        case mixxx::TrackRecord::SourceSyncStatus::Outdated:
            if (syncTrackMetadata) {
                expectedSourceSyncStatusAfter = mixxx::TrackRecord::SourceSyncStatus::Synchronized;
            }
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Void:
        case mixxx::TrackRecord::SourceSyncStatus::Undefined:
            expectedImportResult = mixxx::MetadataSource::ImportResult::Unavailable;
            break;
        case mixxx::TrackRecord::SourceSyncStatus::Synchronized:
            break;
        default:
            ASSERT_FALSE("unreachable");
        }
        if (syncTrackMetadata && !fileLastModifiedAfter.isValid()) {
            // The source sync timestamp should be reset the track
            // metadata export failed due to an inaccessible file.
            expectedSourceSyncStatusAfter = mixxx::TrackRecord::SourceSyncStatus::Unknown;
        }

        // Verify that the modified metadata is still present after
        // reloading the track from the database
        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                &pTrack,
                expectedSourceSyncStatusAfter);
        ASSERT_NE(nullptr, pTrack);
        const auto trackRecordAfter = pTrack->getRecord();

        // Reimport metadata from the file
        mixxx::TrackMetadata importedTrackMetadata;
        auto [importResult, sourceSynchronizedAt] =
                SoundSourceProxy(pTrack).importTrackMetadataAndCoverImage(
                        &importedTrackMetadata, nullptr);
        EXPECT_EQ(expectedImportResult, importResult);

        // The stream info properties might be adjusted when exporting track metadata!
        // We have to adjust trackRecordBefore and importedTrackMetadata accordingly
        // before continuing with the verification.
        if (syncTrackMetadata) {
            trackRecordBefore.refMetadata().refStreamInfo() =
                    trackRecordAfter.getMetadata().getStreamInfo();
            if (importResult == mixxx::MetadataSource::ImportResult::Succeeded) {
                importedTrackMetadata.refStreamInfo() =
                        trackRecordAfter.getMetadata().getStreamInfo();
            }
        }

        // Verify that the metadata in the database has been modified.
        EXPECT_NE(trackRecordBefore.getMetadata(), trackRecordAfter.getMetadata());
        EXPECT_EQ(newTitle, pTrack->getTitle());

        if (syncTrackMetadata) {
            // Verify that the synchronization time stamp has been updated
            // if the file still exists.
            EXPECT_TRUE(
                    !fileLastModifiedAfter.isValid() ||
                    !trackRecordBefore.getSourceSynchronizedAt().isValid() ||
                    trackRecordBefore.getSourceSynchronizedAt() <
                            trackRecordAfter.getSourceSynchronizedAt());
            // Verify that the synchronization time stamp has been reset
            // if the file is inaccessible, i.e. after export of track metadata
            // has failed.
            EXPECT_TRUE(
                    fileLastModifiedAfter.isValid() ||
                    !trackRecordAfter.getSourceSynchronizedAt().isValid());
            if (importResult == mixxx::MetadataSource::ImportResult::Succeeded) {
                // Verify that the metadata in the file has been modified.
                EXPECT_LT(fileLastModifiedBefore, sourceSynchronizedAt);
                EXPECT_EQ(trackRecordAfter.getSourceSynchronizedAt(), sourceSynchronizedAt);
                EXPECT_EQ(trackRecordAfter.getMetadata(), importedTrackMetadata);
            }
        } else {
            // Verify that the synchronization time stamp has not been updated.
            EXPECT_EQ(
                    trackRecordAfter.getSourceSynchronizedAt(),
                    trackRecordBefore.getSourceSynchronizedAt());
            if (importResult == mixxx::MetadataSource::ImportResult::Succeeded) {
                // Verify that the metadata in the file has not been modified.
                EXPECT_EQ(fileLastModifiedBefore, sourceSynchronizedAt);
                EXPECT_EQ(trackRecordBefore.getMetadata(), importedTrackMetadata);
            }
        }
    }

    QDateTime fileLastModified() const {
        return m_tempFileSystem.fileLastModified();
    }

    void updateFileLastModified() const {
        m_tempFileSystem.updateFileLastModified();
    }

    void removeFile() const {
        m_tempFileSystem.removeFile();
    }

  private:
    void createTrack() {
        const auto trackRef = TrackRef::fromFileInfo(m_tempFileSystem.fileInfo());
        ASSERT_FALSE(trackCollectionManager()->getTrackByRef(trackRef));
        const auto pTrack = getOrAddTrackByLocation(trackRef.getLocation());
        ASSERT_TRUE(trackCollectionManager()->getTrackByRef(trackRef));
        m_trackId = pTrack->getId();
        sleepAfterFileLastModifiedUpdated();
    }

    TempFileSystem m_tempFileSystem;
    TrackId m_trackId;
};

class LibraryFileSyncStatusSynchronizedTest : public LibraryFileSyncTest {
  public:
    LibraryFileSyncStatusSynchronizedTest()
            : LibraryFileSyncTest(kTestFileNameWithMetadata) {
    }

  protected:
    TrackPointer prepareTestTrack() const {
        TrackPointer pTrack;
        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                &pTrack,
                mixxx::TrackRecord::SourceSyncStatus::Synchronized);
        return pTrack;
    }
};

TEST_F(LibraryFileSyncStatusSynchronizedTest, checkTrackRecordSourceSyncStatus) {
    const auto pTrack = prepareTestTrack();
    const mixxx::TrackRecord emptyTrackRecord;
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Void,
            emptyTrackRecord.checkSourceSyncStatus(pTrack->getFileInfo()));
    const auto trackRecordOfTestTrack = pTrack->getRecord();
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Synchronized,
            trackRecordOfTestTrack.checkSourceSyncStatus(pTrack->getFileInfo()));
}

TEST_F(LibraryFileSyncStatusSynchronizedTest, saveTrackMetadataWithSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), true);
}

TEST_F(LibraryFileSyncStatusSynchronizedTest, saveTrackMetadataWithSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), false);
}

class LibraryFileSyncStatusUnknownTest : public LibraryFileSyncTest {
  public:
    LibraryFileSyncStatusUnknownTest()
            : LibraryFileSyncTest(kTestFileNameWithMetadata) {
    }

  protected:
    TrackPointer prepareTestTrack() const {
        TrackPointer pTrack;
        establishSourceSyncStatus(&pTrack);
        return pTrack;
    }

  private:
    void establishSourceSyncStatus(TrackPointer* pLoadedTrack) const {
        TrackPointer pTrack;
        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                &pTrack,
                mixxx::TrackRecord::SourceSyncStatus::Synchronized);
        ASSERT_NE(nullptr, pTrack);

        const auto syncTrackMetadataConfigScope =
                SyncTrackMetadataConfigScope(m_pConfig);

        // Disable sync
        syncTrackMetadataConfigScope.setConfig(false);

        const auto fileLastModifiedBefore = fileLastModified();

        // The column contains NULL as the default value, i.e. the last
        // synchronization time is unknown.
        pTrack->resetSourceSynchronizedAt();
        // Write the data into the database (without modifying the file)
        saveModifiedTrack(std::move(pTrack));
        ASSERT_EQ(nullptr, pTrack);

        // Verify that the file has not been modified
        const auto fileLastModifiedAfter = fileLastModified();
        ASSERT_EQ(fileLastModifiedAfter, fileLastModifiedBefore);

        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                pLoadedTrack,
                mixxx::TrackRecord::SourceSyncStatus::Unknown);
    }
};

TEST_F(LibraryFileSyncStatusUnknownTest, checkTrackRecordSourceSyncStatus) {
    const auto pTrack = prepareTestTrack();
    const mixxx::TrackRecord emptyTrackRecord;
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Void,
            emptyTrackRecord.checkSourceSyncStatus(pTrack->getFileInfo()));
    const auto trackRecordOfTestTrack = pTrack->getRecord();
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Unknown,
            trackRecordOfTestTrack.checkSourceSyncStatus(pTrack->getFileInfo()));
}

TEST_F(LibraryFileSyncStatusUnknownTest, saveTrackMetadataWithAndSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), true);
}

TEST_F(LibraryFileSyncStatusUnknownTest, saveTrackMetadataWithAndSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), false);
}

class LibraryFileSyncStatusOutdatedTest : public LibraryFileSyncTest {
  public:
    LibraryFileSyncStatusOutdatedTest()
            : LibraryFileSyncTest(kTestFileNameWithMetadata) {
    }

  protected:
    TrackPointer prepareTestTrack() const {
        TrackPointer pTrack;
        establishSourceSyncStatus(&pTrack);
        return pTrack;
    }

  private:
    void establishSourceSyncStatus(TrackPointer* pLoadedTrack) const {
        // Touch the file's modification time stamp to simulate an external
        // modification by a 3rd party app after the track has been loaded.
        updateFileLastModified();

        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                pLoadedTrack,
                mixxx::TrackRecord::SourceSyncStatus::Outdated);
    }
};

TEST_F(LibraryFileSyncStatusOutdatedTest, checkTrackRecordSourceSyncStatus) {
    const auto pTrack = prepareTestTrack();
    const mixxx::TrackRecord emptyTrackRecord;
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Void,
            emptyTrackRecord.checkSourceSyncStatus(pTrack->getFileInfo()));
    const auto trackRecordOfTestTrack = pTrack->getRecord();
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Outdated,
            trackRecordOfTestTrack.checkSourceSyncStatus(pTrack->getFileInfo()));
}

TEST_F(LibraryFileSyncStatusOutdatedTest, saveTrackMetadataWithAndSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), true);
}

TEST_F(LibraryFileSyncStatusOutdatedTest, saveTrackMetadataWithAndSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), false);
}

TEST_F(LibraryFileSyncStatusOutdatedTest, reimportTrackMetadataWithSyncEnabled) {
    const mixxx::TrackRecord outdatedTrackRecord =
            prepareTestTrack()->getRecord();

    const auto syncTrackMetadataConfigScope =
            SyncTrackMetadataConfigScope(m_pConfig);

    // Enable sync
    syncTrackMetadataConfigScope.setConfig(true);

    auto pTrack = loadTrack();
    ASSERT_TRUE(pTrack);
    const auto importedTrackRecord = pTrack->getRecord();
    verifySourceSyncStatusOfTrack(
            *pTrack, mixxx::TrackRecord::SourceSyncStatus::Synchronized);
    EXPECT_LT(
            outdatedTrackRecord.getSourceSynchronizedAt(),
            importedTrackRecord.getSourceSynchronizedAt());
}

TEST_F(LibraryFileSyncStatusOutdatedTest, doNotReimportTrackMetadataWithSyncDisabled) {
    const mixxx::TrackRecord outdatedTrackRecord =
            prepareTestTrack()->getRecord();

    const auto syncTrackMetadataConfigScope =
            SyncTrackMetadataConfigScope(m_pConfig);

    // Disable sync
    syncTrackMetadataConfigScope.setConfig(false);

    auto pTrack = loadTrack();
    ASSERT_TRUE(pTrack);
    const auto loadedTrackRecord = pTrack->getRecord();
    verifySourceSyncStatusOfTrack(
            *pTrack, mixxx::TrackRecord::SourceSyncStatus::Outdated);
    EXPECT_EQ(outdatedTrackRecord, loadedTrackRecord);
}

class LibraryFileSyncStatusUndefinedTest : public LibraryFileSyncTest {
  public:
    LibraryFileSyncStatusUndefinedTest()
            : LibraryFileSyncTest(kTestFileNameWithMetadata) {
    }

  protected:
    TrackPointer prepareTestTrack() const {
        TrackPointer pTrack;
        establishSourceSyncStatus(&pTrack);
        return pTrack;
    }

  private:
    void establishSourceSyncStatus(TrackPointer* pLoadedTrack) const {
        removeFile();

        loadTrackFromDatabaseAndVerifySourceSyncStatus(
                pLoadedTrack,
                mixxx::TrackRecord::SourceSyncStatus::Undefined);
    }
};

TEST_F(LibraryFileSyncStatusUndefinedTest, checkTrackRecordSourceSyncStatus) {
    const auto pTrack = prepareTestTrack();
    const mixxx::TrackRecord emptyTrackRecord;
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Void,
            emptyTrackRecord.checkSourceSyncStatus(pTrack->getFileInfo()));
    const auto trackRecordOfTestTrack = pTrack->getRecord();
    EXPECT_EQ(mixxx::TrackRecord::SourceSyncStatus::Undefined,
            trackRecordOfTestTrack.checkSourceSyncStatus(pTrack->getFileInfo()));
}

TEST_F(LibraryFileSyncStatusUndefinedTest, saveTrackMetadataWithAndSyncEnabled) {
    modifyAndSaveTrack(prepareTestTrack(), true);
}

TEST_F(LibraryFileSyncStatusUndefinedTest, saveTrackMetadataWithAndSyncDisabled) {
    modifyAndSaveTrack(prepareTestTrack(), false);
}
